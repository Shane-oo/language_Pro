import textwrap
<<<<<<< HEAD
import typing as t
=======
>>>>>>> main
from contextlib import contextmanager


class TextWrapper(textwrap.TextWrapper):
<<<<<<< HEAD
    def _handle_long_word(
        self,
        reversed_chunks: t.List[str],
        cur_line: t.List[str],
        cur_len: int,
        width: int,
    ) -> None:
=======
    def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):
>>>>>>> main
        space_left = max(width - cur_len, 1)

        if self.break_long_words:
            last = reversed_chunks[-1]
            cut = last[:space_left]
            res = last[space_left:]
            cur_line.append(cut)
            reversed_chunks[-1] = res
        elif not cur_line:
            cur_line.append(reversed_chunks.pop())

    @contextmanager
<<<<<<< HEAD
    def extra_indent(self, indent: str) -> t.Iterator[None]:
=======
    def extra_indent(self, indent):
>>>>>>> main
        old_initial_indent = self.initial_indent
        old_subsequent_indent = self.subsequent_indent
        self.initial_indent += indent
        self.subsequent_indent += indent
<<<<<<< HEAD

=======
>>>>>>> main
        try:
            yield
        finally:
            self.initial_indent = old_initial_indent
            self.subsequent_indent = old_subsequent_indent

<<<<<<< HEAD
    def indent_only(self, text: str) -> str:
        rv = []

        for idx, line in enumerate(text.splitlines()):
            indent = self.initial_indent

            if idx > 0:
                indent = self.subsequent_indent

            rv.append(f"{indent}{line}")

=======
    def indent_only(self, text):
        rv = []
        for idx, line in enumerate(text.splitlines()):
            indent = self.initial_indent
            if idx > 0:
                indent = self.subsequent_indent
            rv.append(indent + line)
>>>>>>> main
        return "\n".join(rv)
